--// Structure taken from https://github.com/shlexware/Sirius/blob/request/library/sense/source.lua (they have like the most optimized structure) | Elements have been rewritten --\\

-- Services
local run_service = game:GetService("RunService");
local players = game:GetService("Players");
local workspace = game:GetService("Workspace");

writefile("pixelop.ttf", game:HttpGet("https://cdn.discordapp.com/attachments/1438028907130519572/1439429291749150821/PixelOperator-Bold.ttf"))

local pixelFontTable = {
    name = "PixelOperator",
    faces = {
        {
            name = "Bold",
            weight = 700,
            style = "normal",
            assetId = getcustomasset("pixelop.ttf")
        }
    }
}

writefile("pixelop_encoded.ttf", game:GetService("HttpService"):JSONEncode(pixelFontTable))

local pixelFont = Font.new(getcustomasset("pixelop_encoded.ttf"), Enum.FontWeight.Bold)

local local_player = players.LocalPlayer;
local camera = workspace.CurrentCamera;
local params = RaycastParams.new(); do
	params.FilterType = Enum.RaycastFilterType.Blacklist;
	params.FilterDescendantsInstances = {camera};
end

-- Locals
local floor = math.floor;
local vector2_new = Vector2.new;
local round = math.round;
local clear = table.clear;
local find = table.find;

-- Methods
local find_first_child = workspace.FindFirstChild;
local find_first_child_of_class = workspace.FindFirstChildOfClass;
local ray_cast = workspace.Raycast;
local lerp_color = Color3.new().Lerp;
local lerp2 = Vector2.zero.Lerp;

-- Constants
local CORNER_BOXES_BOTTOM_OFFSET = vector2_new(0, 1);
local HEALTH_BAR_OFFSET = vector2_new(4, 0);
local HEALTH_BAR_OUTLINE_OFFSET = vector2_new(0, 1);
local VISIBILITY_CACHE_TIME = 0.1; -- Cache visibility for 0.1 seconds

-- Skeleton connections
local SKELETON_CONNECTIONS = {
	{"Head", "UpperTorso"},
	{"UpperTorso", "LowerTorso"},
	{"UpperTorso", "LeftUpperArm"},
	{"LeftUpperArm", "LeftLowerArm"},
	{"LeftLowerArm", "LeftHand"},
	{"UpperTorso", "RightUpperArm"},
	{"RightUpperArm", "RightLowerArm"},
	{"RightLowerArm", "RightHand"},
	{"LowerTorso", "LeftUpperLeg"},
	{"LeftUpperLeg", "LeftLowerLeg"},
	{"LeftLowerLeg", "LeftFoot"},
	{"LowerTorso", "RightUpperLeg"},
	{"RightUpperLeg", "RightLowerLeg"},
	{"RightLowerLeg", "RightFoot"},
};

-- Functions
local function world_to_screen(world)
	local screen, on_screen = camera.WorldToViewportPoint(camera, world);
	return vector2_new(screen.X, screen.Y), on_screen, screen.Z;
end

-- ESP Object
local esp_object = {};
esp_object.__index = esp_object;

function esp_object.new(player, interface)
	local self = setmetatable({}, esp_object);
	self.player = assert(player, "Missing argument #1 (Player expected)");
	self.interface = assert(interface, "Missing argument #2 (table expected)");
	self:Construct();
	return self;
end

function esp_object:_create(class, properties)
	local drawing = Drawing.new(class);

	for property, value in properties do
		pcall(function()
			drawing[property] = value;
		end)
	end

	self.bin[#self.bin + 1] = drawing;
	return drawing;
end

function esp_object:Construct()
	self.char_cache = {};
	self.child_count = 0;
	self.bin = {};
	self.visibility_cache = {
		is_visible = false,
		last_check = 0
	};
	
	-- Create highlight for chams
	self.highlight = Instance.new("Highlight");
	self.highlight.Adornee = nil;
	self.highlight.FillTransparency = 0.5;
	self.highlight.OutlineTransparency = 1;
	self.highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop;
	self.highlight.Enabled = false;
	self.highlight.Parent = game:GetService("CoreGui");
	
	self.drawings = {
		visible = {
			box_corners = {
				top_left_vertical_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
        		top_left_horizontal_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
				
        		top_right_vertical_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
        		top_right_horizontal_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
				
        		bottom_left_vertical_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
        		bottom_left_horizontal_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
				
        		bottom_right_vertical_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
        		bottom_right_horizontal_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),

				top_left_vertical = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
        		top_left_horizontal = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
				
        		top_right_vertical = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
        		top_right_horizontal = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
				
        		bottom_left_vertical = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
        		bottom_left_horizontal = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
				
        		bottom_right_vertical = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
        		bottom_right_horizontal = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
			},

			box_outline = self:_create("Square", { Thickness = 3, Visible = false, Filled = false}),
			box = self:_create("Square", { Thickness = 1, Visible = false, Filled = false}),
			box_fill = self:_create("Square", { Thickness = 1, Visible = false, Filled = true}),

			healthbar_outline = self:_create("Line", { Thickness = 3, Visible = false}),
			health_bar = self:_create("Line", { Thickness = 1.5, Visible = false}),

health_visual_text = self:_create("Text", { Text = "", Font = pixelFont, Size = 13, Center = true, Outline = true, OutlineColor = Color3.fromRGB(0,0,0), Visible = false })
name_text = self:_create("Text", { Text = "", Font = pixelFont, Size = 13, Center = true, Outline = true, OutlineColor = Color3.fromRGB(0,0,0), Visible = false })
weapon_text = self:_create("Text", { Text = "", Font = pixelFont, Size = 13, Center = true, Outline = true, OutlineColor = Color3.fromRGB(0,0,0), Visible = false })
distance_text = self:_create("Text", { Text = "", Font = pixelFont, Size = 13, Center = true, Outline = true, OutlineColor = Color3.fromRGB(0,0,0), Visible = false })
			
			head_dot_outline = self:_create("Circle", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0), Filled = false}),
			head_dot = self:_create("Circle", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255), Filled = false}),

			offscreen_arrow = self:_create("Triangle", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255), Filled = true}),
		},
		
		skeleton = {}
	};

	-- Create skeleton lines
	for i = 1, #SKELETON_CONNECTIONS do
		self.drawings.skeleton[i] = {
			outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
			line = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) })
		};
	end

	self.render_connection = run_service.Heartbeat:Connect(function()
		self:Update();
		self:Render();
	end)
end

function esp_object:Destruct()
	self.render_connection:Disconnect();

	for i = 1, #self.bin do
		self.bin[i]:Remove();
	end

	if self.highlight then
		self.highlight:Destroy();
	end

	clear(self);
end

function esp_object:CheckVisibility()
	local current_time = tick();
	
	-- Use cached result if still valid
	if current_time - self.visibility_cache.last_check < VISIBILITY_CACHE_TIME then
		return self.visibility_cache.is_visible;
	end
	
	-- Perform new visibility check
	local is_visible = false;
	if self.character and self.character:FindFirstChild("HumanoidRootPart") then
		local root_pos = self.character.HumanoidRootPart.Position;
		local camera_pos = camera.CFrame.Position;
		local direction = (root_pos - camera_pos).Unit * (root_pos - camera_pos).Magnitude;
		
		local ray_result = ray_cast(workspace, camera_pos, direction, params);
		
		if ray_result then
			local hit_character = ray_result.Instance:FindFirstAncestorOfClass("Model");
			is_visible = hit_character == self.character;
		else
			is_visible = true;
		end
	end
	
	-- Update cache
	self.visibility_cache.is_visible = is_visible;
	self.visibility_cache.last_check = current_time;
	
	return is_visible;
end

function esp_object:Update()
	local interface = self.interface;
	local player = self.player;
	local character = interface.get_character(player);

	params.FilterDescendantsInstances = interface.get_ignorelist();
	self.options = interface.team_settings[interface.is_friendly(player) and "friendly" or "enemy"];
	self.character = character;
	self.health, self.max_health = interface.get_health(player);
	self.weapon = interface.get_weapon(player);
	self.name = player.Name;
	self.enabled = self.options.enabled and character and not (#interface.whitelist > 0 and not find(interface.whitelist, player.UserId));

	local head = self.enabled and find_first_child(character, "Head");
	local humanoid_root_part = self.enabled and find_first_child(character, "HumanoidRootPart");

	if (not head) or (not humanoid_root_part) then
		self.char_cache = {};
		self.on_screen = false;
		
		if self.highlight then
			self.highlight.Enabled = false;
			self.highlight.Adornee = nil;
		end
		
		return;
	end

	local root_position = humanoid_root_part.Position - Vector3.new(0, 0.35, 0);
	local screen_position, on_screen, depth = world_to_screen(root_position);

	self.on_screen = on_screen;
	self.distance = depth;

	if (interface.shared_settings.limit_distance and depth > interface.shared_settings.max_distance) then
		self.on_screen = false;
	end

	if (self.on_screen) then
        local scale = (humanoid_root_part.Size.Y * camera.ViewportSize.Y) / ((2 * depth * math.tan(math.rad(camera.FieldOfView) / 2)) * 1.5);
        
		local height = 4 * scale;
        local width = 2.5 * scale;
	
		local top_left = vector2_new(round(screen_position.X - (width / 2)), round(screen_position.Y - (height / 2)));
		local bottom_right = vector2_new(round(screen_position.X + (width / 2)), round(screen_position.Y + (height / 2)));
	
		self.corners = {
			top_left = top_left,
			bottom_right = bottom_right,
			bottom_left = vector2_new(top_left.X, bottom_right.Y),
			top_right = vector2_new(bottom_right.X, top_left.Y)
		};
		
		-- Head position for head dot
		if head then
			local head_pos, head_on_screen = world_to_screen(head.Position);
			self.head_position = head_pos;
			self.head_on_screen = head_on_screen;
		end
	else
		-- Calculate off-screen indicator position
		if humanoid_root_part then
			local viewport_size = camera.ViewportSize;
			local center = vector2_new(viewport_size.X / 2, viewport_size.Y / 2);
			
			local direction = (screen_position - center).Unit;
			local angle = math.atan2(direction.Y, direction.X);
			
			-- Position arrow at edge of screen
			local edge_distance = math.min(viewport_size.X, viewport_size.Y) * 0.45;
			local arrow_pos = center + direction * edge_distance;
			
			self.offscreen_arrow_position = arrow_pos;
			self.offscreen_arrow_rotation = angle;
		end
	end
end

function esp_object:Render()
	local on_screen = self.on_screen or false;
	local enabled = self.enabled or false;
	local visible = self.drawings.visible;
	local options = self.options;
	local corners = self.corners;

	local vis = (enabled and on_screen and options.box);
	local pos = vis and corners.top_left;
	local size = vis and corners.bottom_right - pos;

	-- Boxes
	do
		local box_type = options.box_type or "box";
		
		-- Box
		do
			visible.box.Visible = vis and options.box_type == "box";
			visible.box_outline.Visible = visible.box.Visible;
			visible.box_fill.Visible = vis and options.box_type == "box" and options.box_fill;

			if (box_type == "box" and (visible.box.Visible or visible.box_fill.Visible)) then
				local box = visible.box;
				box.Position = pos;
				box.Size = size;
				box.Color = options.box_color;
				box.Transparency = 1;

				local box_outline = visible.box_outline;
				box_outline.Position = box.Position;
				box_outline.Size = box.Size;
				box_outline.Color = Color3.fromRGB(0, 0, 0);
				box_outline.Transparency = 1;
				
				if visible.box_fill.Visible then
					local box_fill = visible.box_fill;
					box_fill.Position = pos;
					box_fill.Size = size;
					box_fill.Color = options.box_fill_color;
					box_fill.Transparency = options.box_fill_transparency;
				end
			end
		end

		-- Corner
		do
			local box_corners = visible.box_corners;

			for index, object in box_corners do
				if (not string.find(index, "outline")) then
					object.Color = options.box_color;
				end

				object.Visible = vis and options.box_type == "corner";
			end
		
			if (box_type == "corner" and vis) then
				local position = pos + size / 2;
				local width = size.X / 2;
				local height = size.Y / 2;
			
				local corner_length = math.clamp(1 / self.distance * 750, 1, 300);

				local top_left_position = vector2_new(floor(position.X - width), floor(position.Y - height));
				local top_right_position = vector2_new(floor(position.X + width), floor(position.Y - height ));
				local bottom_left_position = vector2_new(floor(position.X - width), floor(position.Y + height)) - CORNER_BOXES_BOTTOM_OFFSET;
				local bottom_right_position = vector2_new(floor(position.X + width), floor(position.Y + height)) - CORNER_BOXES_BOTTOM_OFFSET;
			
				-- Elements
				local top_left_vertical = box_corners.top_left_vertical;
				top_left_vertical.From = top_left_position;
				top_left_vertical.To = vector2_new(top_left_position.X, top_left_position.Y + corner_length);
				
				local top_left_horizontal = box_corners.top_left_horizontal;
				top_left_horizontal.From = top_left_position;
				top_left_horizontal.To = vector2_new(top_left_position.X + corner_length, top_left_position.Y);
				
				local top_right_vertical = box_corners.top_right_vertical;
				top_right_vertical.From = top_right_position;
				top_right_vertical.To = vector2_new(top_right_position.X, top_right_position.Y + corner_length);
				
				local top_right_horizontal = box_corners.top_right_horizontal;
				top_right_horizontal.From = top_right_position;
				top_right_horizontal.To = vector2_new(top_right_position.X - corner_length, top_right_position.Y);
				
				local bottom_left_vertical = box_corners.bottom_left_vertical;
				bottom_left_vertical.From = bottom_left_position;
				bottom_left_vertical.To = vector2_new(bottom_left_position.X, bottom_left_position.Y - corner_length);
				
				local bottom_left_horizontal = box_corners.bottom_left_horizontal;
				bottom_left_horizontal.From = bottom_left_position;
				bottom_left_horizontal.To = vector2_new(bottom_left_position.X + corner_length, bottom_left_position.Y)
				
				local bottom_right_vertical = box_corners.bottom_right_vertical;
				bottom_right_vertical.From = vector2_new(bottom_right_position.X, bottom_right_position.Y + 1);
				bottom_right_vertical.To = vector2_new(bottom_right_position.X, bottom_right_position.Y - corner_length);
				
				local bottom_right_horizontal = box_corners.bottom_right_horizontal;
				bottom_right_horizontal.From = bottom_right_position;
				bottom_right_horizontal.To = vector2_new(bottom_right_position.X - corner_length, bottom_right_position.Y);
			
				-- Outline
				do
						local top_right_vertical_outline = box_corners.top_right_vertical_outline;
						top_right_vertical_outline.From = vector2_new(top_right_vertical.From.X, top_right_vertical.From.Y - 1.2);
						top_right_vertical_outline.To = vector2_new(top_right_vertical.To.X, top_right_vertical.To.Y + 1);

						local bottom_right_horizontal_outline = box_corners.bottom_right_horizontal_outline;
						bottom_right_horizontal_outline.From = vector2_new(bottom_right_horizontal.From.X + 1.2, bottom_right_horizontal.From.Y);
						bottom_right_horizontal_outline.To = vector2_new(bottom_right_horizontal.To.X - 1, bottom_right_horizontal.To.Y);

						local bottom_right_vertical_outline = box_corners.bottom_right_vertical_outline;
						bottom_right_vertical_outline.From = vector2_new(bottom_right_vertical.From.X, bottom_right_vertical.From.Y);
						bottom_right_vertical_outline.To = vector2_new(bottom_right_vertical.To.X, bottom_right_vertical.To.Y - 1);

						local top_right_horizontal_outline = box_corners.top_right_horizontal_outline;
						top_right_horizontal_outline.From = vector2_new(top_right_horizontal.From.X, top_right_horizontal.From.Y)
						top_right_horizontal_outline.To = vector2_new(top_right_horizontal.To.X - 1, top_right_horizontal.To.Y);

						local top_left_horizontal_outline = box_corners.top_left_horizontal_outline;
						top_left_horizontal_outline.From = vector2_new(top_left_horizontal.From.X - 1, top_left_horizontal.From.Y);
						top_left_horizontal_outline.To = vector2_new(top_left_horizontal.To.X + 1, top_left_horizontal.To.Y);

						local top_left_vertical_outline = box_corners.top_left_vertical_outline;
						top_left_vertical_outline.From = vector2_new(top_left_vertical.From.X, top_left_vertical.From.Y);
						top_left_vertical_outline.To = vector2_new(top_left_vertical.To.X, top_left_vertical.To.Y + 1);

						local bottom_left_horizontal_outline = box_corners.bottom_left_horizontal_outline;
						bottom_left_horizontal_outline.From = vector2_new(bottom_left_horizontal.From.X - 1, bottom_left_horizontal.From.Y);
						bottom_left_horizontal_outline.To = vector2_new(bottom_left_horizontal.To.X + 1, bottom_left_horizontal.To.Y);

						local bottom_left_vertical_outline = box_corners.bottom_left_vertical_outline;
						bottom_left_vertical_outline.From = vector2_new(bottom_left_vertical.From.X, bottom_left_vertical.From.Y);
						bottom_left_vertical_outline.To = vector2_new(bottom_left_vertical.To.X, bottom_left_vertical.To.Y - 1);
				end
			end
		end
    end

    -- Healthbar
	do
		local health_bar = visible.health_bar;

        health_bar.Visible = (enabled and on_screen) and options.health_bar;
	    visible.healthbar_outline.Visible = health_bar.Visible;

	    if (health_bar.Visible) then
			local bar_from = corners.top_left - HEALTH_BAR_OFFSET
			local bar_to = corners.bottom_left - HEALTH_BAR_OFFSET
		
			health_bar.To = bar_to
			health_bar.From = lerp2(bar_to, bar_from, self.health / self.max_health)
			health_bar.Color = (options.dynamic_color and lerp_color(options.dying_color, options.healthy_color, self.health / self.max_health)) or options.health_bar_color
		
			local healthbar_outline = visible.healthbar_outline
			healthbar_outline.To = bar_to + HEALTH_BAR_OUTLINE_OFFSET
			healthbar_outline.From = bar_from - HEALTH_BAR_OUTLINE_OFFSET
			healthbar_outline.Color = Color3.fromRGB(0, 0, 0)
		end

		-- Health Text
		do
            local health_text = visible.health_visual_text;
            health_text.Visible = (enabled and on_screen) and options.health_text and health_bar.Visible;

            if (health_text.Visible) then
                health_text.Text = math.floor(self.health + 0.5);
                health_text.Color = options.health_text_color;

                health_text.Position = health_bar.From + Vector2.new(-13, -3);
            end
        end
	end

	-- Name
	do
		local name = visible.name_text;
		name.Visible = (enabled and on_screen) and options.name_text;

		if (name.Visible) then
			name.Text = self.name;
			name.Color = Color3.new(1, 1, 1);
			name.Position = Vector2.new(pos.X + (size.X / 2), pos.Y - 15) - Vector2.new(0, 2);
		end
	end

	-- Weapon
	do
		local weapon = visible.weapon_text;
		weapon.Visible = (enabled and on_screen) and options.weapon_text;

		if (weapon.Visible) then
			weapon.Text = self.weapon;
			weapon.Color = Color3.new(1, 1, 1);
			weapon.Position = Vector2.new(pos.X + (size.X / 2), pos.Y + size.Y) + Vector2.new(0, 2);
		end
	end

	-- Distance
	do
		local distance = visible.distance_text;
		distance.Visible = (enabled and on_screen) and options.distance_text;

		if (distance.Visible) then
			distance.Text = math.floor(self.distance) .. "s";
			distance.Color = options.distance_text_color;
			
			local y_offset = options.weapon_text and 17 or 2;
			distance.Position = Vector2.new(pos.X + (size.X / 2), pos.Y + size.Y) + Vector2.new(0, y_offset);
		end
	end

	-- Head Dot
	do
		local head_dot = visible.head_dot;
		local head_dot_outline = visible.head_dot_outline;
		
		head_dot.Visible = (enabled and on_screen) and options.head_dot and self.head_on_screen;
		head_dot_outline.Visible = head_dot.Visible;

		if (head_dot.Visible) then
			local radius = math.clamp(1000 / self.distance, 3, 15);
			
			head_dot.Position = self.head_position;
			head_dot.Radius = radius;
			head_dot.Color = options.head_dot_color;
			
			head_dot_outline.Position = self.head_position;
			head_dot_outline.Radius = radius;
			head_dot_outline.Color = Color3.fromRGB(0, 0, 0);
		end
	end

	-- Skeleton
	do
		local skeleton_visible = (enabled and on_screen) and options.skeleton;
		
		for i = 1, #SKELETON_CONNECTIONS do
			local connection = SKELETON_CONNECTIONS[i];
			local drawing_pair = self.drawings.skeleton[i];
			
			drawing_pair.line.Visible = false;
			drawing_pair.outline.Visible = false;
			
			if skeleton_visible and self.character then
				local part1 = find_first_child(self.character, connection[1]);
				local part2 = find_first_child(self.character, connection[2]);
				
				if part1 and part2 then
					local pos1, on_screen1 = world_to_screen(part1.Position);
					local pos2, on_screen2 = world_to_screen(part2.Position);
					
					if on_screen1 and on_screen2 then
						drawing_pair.outline.Visible = true;
						drawing_pair.outline.From = pos1;
						drawing_pair.outline.To = pos2;
						drawing_pair.outline.Color = Color3.fromRGB(0, 0, 0);
						
						drawing_pair.line.Visible = true;
						drawing_pair.line.From = pos1;
						drawing_pair.line.To = pos2;
						drawing_pair.line.Color = options.skeleton_color;
					end
				end
			end
		end
	end

	-- Off-screen Indicator
	do
		local arrow = visible.offscreen_arrow;
		arrow.Visible = enabled and not on_screen and options.offscreen_arrow and self.offscreen_arrow_position;

		if (arrow.Visible) then
			local arrow_size = 15;
			local angle = self.offscreen_arrow_rotation;
			
			-- Calculate triangle points
			local tip = self.offscreen_arrow_position;
			local base_left = tip + vector2_new(
				math.cos(angle + 2.5) * arrow_size,
				math.sin(angle + 2.5) * arrow_size
			);
			local base_right = tip + vector2_new(
				math.cos(angle - 2.5) * arrow_size,
				math.sin(angle - 2.5) * arrow_size
			);
			
			arrow.PointA = tip;
			arrow.PointB = base_left;
			arrow.PointC = base_right;
			arrow.Color = options.offscreen_arrow_color;
		end
	end

	-- Chams (Highlight)
	do
		if self.highlight then
			self.highlight.Enabled = enabled and options.chams;
			
			if self.highlight.Enabled then
				self.highlight.Adornee = self.character;
				
				-- Use cached visibility check
				local is_visible = self:CheckVisibility();
				
				-- Set colors based on visibility
				if is_visible then
					self.highlight.FillColor = options.chams_visible_color;
				else
					self.highlight.FillColor = options.chams_occluded_color;
				end
			else
				self.highlight.Adornee = nil;
			end
		end
	end
end

-- interface
local esp = {
	loaded = false,
	object_cache = {},
	whitelist = {},
	shared_settings = {
		limit_distance = false,
		max_distance = 100,
	},
	team_settings = {
		enemy = {
			enabled = false,

			box = false,
			box_type = "box", -- corner & box
			box_fill = false,

			weapon_text = false,
			health_text = false,
			name_text = false,
			distance_text = false,

			health_bar = false,
			dynamic_color = false,

			chams = false,
			head_dot = false,
			skeleton = false,
			offscreen_arrow = false,

			box_color = Color3.fromRGB(255, 255, 255),
			box_fill_color = Color3.fromRGB(255, 255, 255),
			box_fill_transparency = 0.5,
			weapon_text_color = Color3.fromRGB(255, 255, 255),
			name_text_color = Color3.fromRGB(255, 255, 255),
			distance_text_color = Color3.fromRGB(255, 255, 255),

			health_text_color = Color3.fromRGB(255, 255, 255),
			health_bar_color = Color3.fromRGB(255, 255, 255),

			chams_visible_color = Color3.fromRGB(0, 255, 0),
			chams_occluded_color = Color3.fromRGB(255, 0, 0),

			head_dot_color = Color3.fromRGB(255, 255, 255),
			skeleton_color = Color3.fromRGB(255, 255, 255),
			offscreen_arrow_color = Color3.fromRGB(255, 255, 255),

			dying_color = Color3.fromRGB(255, 0, 0),
			healthy_color = Color3.fromRGB(0, 255, 0),
		},
		friendly = {
			enabled = false,

			box = false,
			box_type = "box", -- corner & box
			box_fill = false,

			weapon_text = false,
			health_text = false,
			name_text = false,
			distance_text = false,

			health_bar = false,
			dynamic_color = false,

			chams = false,
			head_dot = false,
			skeleton = false,
			offscreen_arrow = false,

			box_color = Color3.fromRGB(255, 255, 255),
			box_fill_color = Color3.fromRGB(255, 255, 255),
			box_fill_transparency = 0.5,
			weapon_text_color = Color3.fromRGB(255, 255, 255),
			name_text_color = Color3.fromRGB(255, 255, 255),
			distance_text_color = Color3.fromRGB(255, 255, 255),

			health_text_color = Color3.fromRGB(255, 255, 255),
			health_bar_color = Color3.fromRGB(255, 255, 255),

			chams_visible_color = Color3.fromRGB(0, 255, 0),
			chams_occluded_color = Color3.fromRGB(255, 0, 0),

			head_dot_color = Color3.fromRGB(255, 255, 255),
			skeleton_color = Color3.fromRGB(255, 255, 255),
			offscreen_arrow_color = Color3.fromRGB(255, 255, 255),

			dying_color = Color3.fromRGB(255, 0, 0),
			healthy_color = Color3.fromRGB(0, 255, 0),
		},
	}
};

function esp.Load()
	local function create_object(player)
		esp.object_cache[player] = {
			esp_object.new(player, esp),
		};
	end

	local function remove_object(player)
		local object = esp.object_cache[player];
		if object then
			for i = 1, #object do
				object[i]:Destruct();
			end

			esp.object_cache[player] = nil;
		end
	end

	local plrs = players:GetPlayers();
    
	for i = 2, #plrs do
		create_object(plrs[i]);
	end

	esp.playerAdded = players.PlayerAdded:Connect(create_object);
	esp.playerRemoving = players.PlayerRemoving:Connect(remove_object);
	esp.loaded = true;
end

function esp.Unload()
	for index, object in esp.object_cache do
		for i = 1, #object do
			object[i]:Destruct();
		end

		esp.object_cache[index] = nil;
	end

	esp.playerAdded:Disconnect();
	esp.playerRemoving:Disconnect();
	esp.loaded = false;
end

-- game specific functions
function esp.get_ignorelist()
	return {local_player.Character, camera};
end

function esp.get_weapon(player)
    local character = player.Character;

    if (not character) then
        return "Nothing";
    end

	for index, value in character:GetChildren() do
        if value.Name ~= "HolsterModel" and value:IsA("Model") and value.Name ~= "Hair" and (value:FindFirstChild("Detail") or value:FindFirstChild("Main") or value:FindFirstChild("Handle") or value:FindFirstChild("Attachments") or value:FindFirstChild("ArrowAttach") or value:FindFirstChild("Attach")) and value.PrimaryPart then
            return value.Name
        end
    end

    return "Nothing";
end

function esp.is_friendly(player)
	return player.Team and player.Team == local_player.Team;
end

function esp.get_character(player)
	return player.Character;
end

function esp.get_health(player)
	local character = player and esp.get_character(player);
	local humanoid = character and find_first_child_of_class(character, "Humanoid");

	if (humanoid) then
		return humanoid.Health, humanoid.MaxHealth;
	end

	return 100, 100;
end

--esp.Load();
return esp;
